<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VISUALIZATION</title>
    <link rel="stylesheet" href="../../../static/css/main.css">
    <link rel="stylesheet" href="../../../static/css/algorithm.css">
    <link rel="stylesheet" href="../../../static/css/frame.css">
    <script src="main.js" defer></script>
    <!-- Google Font: Montserrat for logo text -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
</head>

<body>
    <header class="tool1">
        <div class="frame-logo1">
            <span class="secondtext-tool1">KaTiLa</span>
            <span class="maintext-tool1">VISUALIZATION</span>
        </div>

        <nav class="menu">
            <ul>
                <li><a href="../indexhome.html">Home</a></li>
                <li><a href="#">Community</a></li>
                <li class="dropdown">
                    <a href="#">Algorithms ▼</a>
                    <div class="dropdown-content">
                        <a href="../Algorithm/overviewbfs.html">BFS</a>
                        <a href="../Algorithm/overviewdfs.html">DFS</a>
                        <a href="../Algorithm/overviewdij.html">Dijkstra</a>
                        <a href="../Algorithm/overviewa.html">A*</a>
                        <a href="../Algorithm/overviewfc.html">Foward Chaining</a>
                        <a href="../Algorithm/overviewminimax.html">Mini Max</a>
                        <a href="../Algorithm/overviewffill.html">Flood Fill</a>
                    </div>
                </li>
                <li><a href="#">History</a></li>
                <li><a href="#">Docs</a></li>
                <li><a href="#">Member</a></li>
            </ul>
        </nav>


        <div class="frame-icon">
            <span class="menu_icon">&#9776;</span>
        </div>
    </header>

    <header class="tool2">
        <a href="../Algorithm/overviewa.html" class="overview"><span>Overview</span></a>
        <a href="../Algorithm/theorya.html" class="theory"><span>Theory</span></a>
        <a href="../Algorithm/simulationa.html" class="simulation"><span>Simulation</span></a>
        <a href="../Algorithm/stepbystepa.html" class="stepbystep"><span>Step by Step</span></a>
        <a href="../Algorithm/quiza.html" class="quiz"><span>Quiz</span></a>
    </header>

    <div class="container">
        <h1>A* Search Algorithm</h1>
        <p>
            Thuật toán A* (A-star) là một trong những thuật toán tìm kiếm đường đi ngắn nhất nổi tiếng và hiệu quả nhất
            trong trí tuệ nhân tạo (AI), đặc biệt trong các bài toán lập kế hoạch đường đi (pathfinding) và tìm kiếm
            trạng thái (state-space search).
        </p>
        <p>
            A* là sự kết hợp giữa hai chiến lược:
        </p>
        <ul>
            <li>Tìm kiếm theo chi phí nhỏ nhất (Uniform Cost Search) – đảm bảo tìm đường đi ngắn nhất.</li>
            <li>Tìm kiếm theo heuristic (Greedy Best-First Search) – hướng dẫn tìm kiếm nhanh hơn dựa vào ước lượng
                khoảng cách còn lại.</li>
        </ul>

        <h2>Ý tưởng (Idea)</h2>
        <p>
            Mỗi nút <i>n</i> trong không gian tìm kiếm được gán một giá trị đánh giá <b>f(n)</b>:
        </p>
        <pre>f(n) = g(n) + h(n)</pre>
        <ul>
            <li><b>g(n)</b>: Chi phí thực từ điểm bắt đầu đến nút hiện tại.</li>
            <li><b>h(n)</b>: Chi phí ước lượng (heuristic) từ nút hiện tại đến đích.</li>
            <li><b>f(n)</b>: Tổng chi phí ước lượng từ đầu → n → đích.</li>
        </ul>
        <p>
            Thuật toán luôn mở rộng nút có giá trị <b>f(n)</b> nhỏ nhất, cân bằng giữa chi phí đã đi (g) và chi phí dự
            đoán còn lại (h).
        </p>

        <img src="https://upload.wikimedia.org/wikipedia/commons/9/98/AstarExampleEn.gif"
            alt="Minh họa A* Search">

        <h2>Thuật toán (Algorithm)</h2>
        <pre>
A*(start, goal):
    openSet = {start}
    cameFrom = empty map
    gScore[start] = 0
    fScore[start] = h(start)

    while openSet is not empty:
        current = node in openSet with lowest fScore
        if current == goal:
            return reconstruct_path(cameFrom, current)

        remove current from openSet
        for each neighbor of current:
            tentative_g = gScore[current] + dist(current, neighbor)
            if tentative_g < gScore[neighbor]:
                cameFrom[neighbor] = current
                gScore[neighbor] = tentative_g
                fScore[neighbor] = gScore[neighbor] + h(neighbor)
                if neighbor not in openSet:
                    add neighbor to openSet
    return failure
            </pre>

        <h2>Mã giả (Pseudocode)</h2>
        <pre>
function A_Star(start, goal)
    openSet ← {start}
    gScore[start] ← 0
    fScore[start] ← h(start)
    while openSet ≠ ∅ do
        current ← node in openSet with lowest fScore
        if current = goal then
            return path(current)
        remove current from openSet
        for each neighbor of current do
            tentative_g ← gScore[current] + distance(current, neighbor)
            if tentative_g < gScore[neighbor] then
                cameFrom[neighbor] ← current
                gScore[neighbor] ← tentative_g
                fScore[neighbor] ← gScore[neighbor] + h(neighbor)
                if neighbor not in openSet then
                    add neighbor to openSet
    return failure
            </pre>

        <h2>Phân tích độ phức tạp (Complexity Analysis)</h2>
        <ul>
            <li>Thời gian (Time Complexity): O(E) trong trường hợp heuristic tốt, nhưng có thể tăng lên O(b<sup>d</sup>)
                trong trường hợp xấu nhất.</li>
            <li>Không gian (Space Complexity): O(V), do cần lưu trữ danh sách mở (open set), danh sách đóng (closed
                set), gScore, fScore và cameFrom.</li>
        </ul>
        <p>
            Hiệu quả của A* phụ thuộc vào chất lượng của hàm heuristic <b>h(n)</b>:
        </p>
        <ul>
            <li>Nếu <b>h(n)</b> ≤ chi phí thực tế đến đích, A* được đảm bảo tối ưu.</li>
            <li>Nếu <b>h(n)</b> = 0 → A* trở thành Dijkstra.</li>
            <li>Nếu <b>h(n)</b> quá lớn → A* giống Greedy Search (nhanh hơn nhưng không đảm bảo tối ưu).</li>
        </ul>

        <h2>Ví dụ về hàm heuristic</h2>
        <ul>
            <li>Khoảng cách Manhattan: |x1 - x2| + |y1 - y2| (khi chỉ di chuyển 4 hướng).</li>
            <li>Khoảng cách Euclidean: √((x1 - x2)² + (y1 - y2)²) (khi di chuyển chéo được).</li>
            <li>Khoảng cách Chebyshev: max(|x1 - x2|, |y1 - y2|) (khi di chuyển 8 hướng).</li>
        </ul>

        <h2>Ứng dụng (Applications)</h2>
        <ul>
            <li>Tìm đường đi trong bản đồ và game (AI pathfinding – ví dụ: Pac-Man, RTS game, GPS).</li>
            <li>Tìm kiếm trong không gian trạng thái (state-space search).</li>
            <li>Lập kế hoạch robot (robot motion planning).</li>
            <li>Giải bài toán ô trượt (8-puzzle, 15-puzzle).</li>
            <li>Định tuyến mạng (network routing).</li>
        </ul>

        <h2>Tính chất và đặc điểm</h2>
        <ul>
            <li>A* luôn tìm được đường đi ngắn nhất nếu hàm heuristic là <b>admissible</b> (không vượt quá chi phí
                thật).</li>
            <li>Là thuật toán tìm kiếm theo thông tin (informed search) vì có sử dụng ước lượng h(n).</li>
            <li>Có thể điều chỉnh để tối ưu tốc độ hoặc độ chính xác bằng cách thay đổi heuristic.</li>
            <li>Là nền tảng cho nhiều thuật toán mở rộng như Weighted A*, Theta*, Jump Point Search.</li>
        </ul>
    </div>
</body>

</html>