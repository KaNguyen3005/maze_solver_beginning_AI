<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VISUALIZATION</title>
    <link rel="stylesheet" href="../../../static/css/main.css">
    <link rel="stylesheet" href="../../../static/css/algorithm.css">
    <link rel="stylesheet" href="../../../static/css/frame.css">
    <script src="main.js" defer></script>
    <!-- Google Font: Montserrat for logo text -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
</head>

<body>
    <header class="tool1">
        <div class="frame-logo1">
            <span class="secondtext-tool1">KaTiLa</span>
            <span class="maintext-tool1">VISUALIZATION</span>
        </div>

        <nav class="menu">
            <ul>
                <li><a href="../indexhome.html">Home</a></li>
                <li><a href="#">Community</a></li>
                <li class="dropdown">
                    <a href="#">Algorithms ▼</a>
                    <div class="dropdown-content">
                        <a href="../Algorithm/overviewbfs.html">BFS</a>
                        <a href="../Algorithm/overviewdfs.html">DFS</a>
                        <a href="../Algorithm/overviewdij.html">Dijkstra</a>
                        <a href="../Algorithm/overviewa.html">A*</a>
                        <a href="../Algorithm/overviewfc.html">Foward Chaining</a>
                        <a href="../Algorithm/overviewminimax.html">Mini Max</a>
                        <a href="../Algorithm/overviewffill.html">Flood Fill</a>
                    </div>
                </li>
                <li><a href="#">History</a></li>
                <li><a href="#">Docs</a></li>
                <li><a href="#">Member</a></li>
            </ul>
        </nav>


        <div class="frame-icon">
            <span class="menu_icon">&#9776;</span>
        </div>
    </header>

    <header class="tool2">
        <a href="../Algorithm/overviewdij.html" class="overview"><span>Overview</span></a>
        <a href="../Algorithm/theorydij.html" class="theory"><span>Theory</span></a>
        <a href="../Algorithm/simulationdij.html" class="simulation"><span>Simulation</span></a>
        <a href="../Algorithm/stepbystepdij.html" class="stepbystep"><span>Step by Step</span></a>
        <a href="../Algorithm/quizdij.html" class="quiz"><span>Quiz</span></a>
    </header>

    <div class="container">
        <h1>Dijkstra</h1>
        <p>
            Thuật toán Dijkstra là thuật toán cổ điển để tìm đường đi ngắn nhất từ một đỉnh nguồn đến mọi đỉnh khác
            trong đồ thị có trọng số không âm.
            Được phát minh bởi Edsger W. Dijkstra vào những năm 1950, thuật toán này là nền tảng cho nhiều ứng dụng như
            định tuyến mạng, hệ thống bản đồ và các bài toán tối ưu hóa.
        </p>

        <h2>Ý tưởng (Idea)</h2>
        <ul>
            <li>Mỗi đỉnh giữ một giá trị <code>dist[v]</code> biểu diễn khoảng cách nhỏ nhất ước tính từ nguồn đến v.
            </li>
            <li>Ban đầu đặt <code>dist[source] = 0</code> và <code>dist[others] = ∞</code>.</li>
            <li>Lặp: chọn đỉnh chưa được cố định (finalized) có <code>dist</code> nhỏ nhất, cập nhật khoảng cách của các
                nút kề bằng thao tác "relaxation".</li>
            <li>Tiếp tục cho đến khi tất cả đỉnh được cố định hoặc không còn đỉnh có thể tiếp cận.</li>
        </ul>

        <img src="https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif" alt="Minh họa Dijkstra" />

        <h2>Thuật toán (Algorithm)</h2>
        <pre>
Dijkstra(graph, source):
    for each vertex v in graph:
        dist[v] = infinity
        previous[v] = undefined
    dist[source] = 0

    Q = all vertices in graph (min-priority queue ordered by dist)

    while Q not empty:
        u = extract-min(Q)
        for each neighbor v of u:
            alt = dist[u] + weight(u, v)
            if alt < dist[v]:
                dist[v] = alt
                previous[v] = u
                decrease-key(Q, v, alt)
    return dist[], previous[]
        </pre>

        <h2>Mã giả (Pseudocode)</h2>
        <pre>
function Dijkstra(Graph, source):
    for each vertex v in Graph:
        dist[v] := infinity
        prev[v] := null
    dist[source] := 0
    Q := min-priority-queue containing all vertices keyed by dist[]

    while Q is not empty:
        u := Extract-Min(Q)
        for each neighbor v of u:
            alt := dist[u] + length(u, v)
            if alt < dist[v]:
                dist[v] := alt
                prev[v] := u
                Decrease-Key(Q, v, alt)
    return dist, prev
        </pre>

        <h2>Triển khai ví dụ</h2>

        <h3>Code C++ (sử dụng priority_queue)</h3>
        <pre>
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int,int>; // (dist, node)

vector<vector<pair<int,int>>> adj; // adj[u] = {(v, w), ...}
vector<int> dijkstra(int n, int source) {
    const int INF = 1e9;
    vector<int> dist(n+1, INF);
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    dist[source] = 0;
    pq.push({0, source});

    while (!pq.empty()) {
        auto [du, u] = pq.top(); pq.pop();
        if (du != dist[u]) continue;
        for (auto [v, w] : adj[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
    return dist;
}
        </pre>

        <h3>Code Python (sử dụng heapq)</h3>
        <pre>
import heapq

def dijkstra(n, adj, source):
    INF = 10**18
    dist = [INF] * (n + 1)
    dist[source] = 0
    pq = [(0, source)]
    while pq:
        d, u = heapq.heappop(pq)
        if d != dist[u]:
            continue
        for v, w in adj[u]:
            nd = d + w
            if nd < dist[v]:
                dist[v] = nd
                heapq.heappush(pq, (nd, v))
    return dist
        </pre>

        <h2>Phân tích độ phức tạp (Complexity Analysis)</h2>
        <ul>
            <li>Trường hợp đơn giản (ma trận khoảng cách hoặc tìm min bằng linear scan): O(V^2).</li>
            <li>Sử dụng priority queue (binary heap): O((V + E) log V) ≈ O(E log V) cho đồ thị thưa.</li>
            <li>Sử dụng Fibonacci heap (lý thuyết): O(V log V + E).</li>
            <li>Không gian: O(V + E) để lưu biểu diễn đồ thị và mảng dist/prev.</li>
        </ul>

        <h2>Tính chất & lưu ý</h2>
        <ul>
            <li>Đòi hỏi: tất cả trọng số cạnh phải không âm. Nếu có cạnh âm, dùng Bellman-Ford.</li>
            <li>Dijkstra tìm đường ngắn nhất từ một nguồn đến mọi đỉnh khác (single-source shortest path).</li>
            <li>Nếu bạn chỉ cần đường ngắn nhất giữa hai đỉnh, có thể dùng biến thể bidirectional Dijkstra để tăng tốc.
            </li>
            <li>Độ phức tạp thực tế phụ thuộc vào cấu trúc dữ liệu cho hàng đợi ưu tiên và biểu diễn đồ thị (adjacency
                list hay matrix).</li>
        </ul>

        <h2>Ứng dụng (Applications)</h2>
        <ul>
            <li>Hệ thống định tuyến mạng (ví dụ: OSPF sử dụng cơ chế tương tự).</li>
            <li>Hệ thống bản đồ và GPS: tính khoảng cách tối thiểu trên đồ thị đường bộ (khi trọng số không âm).</li>
            <li>Robot path planning trong môi trường có chi phí di chuyển khác nhau.</li>
            <li>Tối ưu hóa logistics, lập lịch và phân tích đường đi trong sơ đồ vận hành.</li>
            <li>Là nhân tố cơ bản để phát triển các thuật toán phức tạp hơn (A*, Johnson's algorithm, v.v.).</li>
        </ul>

        <h2>Kết luận</h2>
        <p>
            Dijkstra là một công cụ cực kỳ quan trọng trong khoa học máy tính và kỹ thuật. Với việc lựa chọn đúng cấu
            trúc dữ liệu (ví dụ: heap), thuật toán có thể xử lý hiệu quả các đồ thị lớn.
            Tuy nhiên, cần lưu ý trọng số cạnh phải không âm; trong các trường hợp có cạnh âm hoặc yêu cầu tối ưu trên
            nhiều nguồn/đa tiêu chí, cần cân nhắc các thuật toán khác.
        </p>
    </div>
</body>

</html>